#!/usr/bin/env bash

# Copyright (C) Indrajit Roy <eendroroy@gmail.com>
#
# SPDX-License-Identifier: AGPL-3.0-or-later
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# shellcheck disable=SC2034
____GITTER____LINK="https://github.com/eendroroy/gitter"
____GITTER_VERSION="0.0.1"
_____SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)

source "$_____SCRIPT_DIR"/../src/__variables.sh
# shellcheck source=/dev/null
for script in "$_____SCRIPT_DIR"/../src/func/*.sh; do source "$script"; done

[[ $# -eq 0 ]] && { __help; exit 1; }

# Argument defaults
command=""
args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    # Parse Commands
    git     |g ) ___git              ;;
    exec    |x ) ___exec             ;;
    eval    |e ) ___eval             ;;
    list    |ls) ___list             ;;
             ll) ___ll               ;;
    config  |c ) ___config           ;;
    help       ) ___help "$@"; break ;;
    version |v ) ___version          ;;

    # Parse Options
    --max-depth         |-d) opts=("${opts[@]}" "${1}"); shift; __read_max_depth "$1"        ;;
    --exclude           |-e) opts=("${opts[@]}" "${1}");        GITTER_FILTER_EXCLUDE=true   ;;
    --filter            |-f) opts=("${opts[@]}" "${1}"); shift; __read_filter "$1"           ;;
    --ask-confirmation  |-a) opts=("${opts[@]}" "${1}");        GITTER_ASK_CONFIRMATION=true ;;
    --continue-on-error |-c) opts=("${opts[@]}" "${1}");        GITTER_CONTINUE_ON_ERROR=true;;
    --quiet             |-q) opts=("${opts[@]}" "${1}");        GITTER_QUIET=true            ;;
    --no-color             ) opts=("${opts[@]}" "${1}");        GITTER_NO_COLOR=true         ;;
    --verbose           |-v) opts=("${opts[@]}" "${1}");        GITTER_VERBOSE=true          ;;
    --dry-run           |-n) opts=("${opts[@]}" "${1}");        GITTER_DRY_RUN=true          ;;

    # Parse Command Arguments
    --) __read_command_args "$@"; break ;;

    # Handle Unknown Options/Arguments
    --*|-*) __unknown_option "$1" ;;
    *     ) __unknown_arg    "$1" ;;
  esac
  shift
done

__validate_command "$command"

[[ "$GITTER_NO_COLOR" == true ]] && __disable_color_output

[[ -z "$command" ]] && command="git"

[[ "$command" == "help"              ]] && { __help;              exit 0; }
[[ "$command" == "help-filter"       ]] && { __help_filter;       exit 0; }
[[ "$command" == "help-gitterignore" ]] && { __help_gitterignore; exit 0; }
[[ "$command" == "help-placeholder"  ]] && { __help_placeholder;  exit 0; }
[[ "$command" == "help-status"       ]] && { __help_status;       exit 0; }
[[ "$command" == "config"            ]] && { __print_config;      exit 0; }
[[ "$command" == "version"           ]] && { __version;      exit 0; }

[[ "$command" != "list" && ${#args[@]} -eq 0 ]] && __invalid_args_for_command "$command"

# -- find all git repositories in the current directory
readarray -d '' -t repositories < <(find . -name ".git" -maxdepth "$((GITTER_MAX_DEPTH+1))" -type d -print0)
[[ ${#repositories[@]} -eq 0 ]] && __no_repository_found

# -- process .gitterignore if exists
[[ -f .gitterignore ]] && __process_gitterignore repositories
[[ ${#repositories[@]} -eq 0 ]] && __all_repositories_ignored

# -- apply user specified filters
__filter_repositories repositories
[[ ${#repositories[@]} -eq 0 ]] && __all_repositories_filtered_out

# -- execute 'list' command
if [[ "$command" == "list" ]]; then
  for repository in "${repositories[@]}"; do
    repo_dir=$(dirname "$repository")
    echo -ne "${GITTER_C_SUCCESS}${GITTER_PRIMARY_SYMBOL}${GITTER_C___RESET} "
    __repo_status "$repo_dir"
    echo
    continue
  done
  exit 0
fi

additional_args=()
# -- set command and args for 'exec' command
[[ "$command" == "git"  ]] && additional_args=("-c" "color.ui=always")
[[ "$command" == "exec" ]] && command="${args[0]}" && args=("${args[@]:1}")

# -- execute git/exec commands in each repository
repo_index=0
total_repos=${#repositories[@]}
for repository in "${repositories[@]}"; do
  parsed_args=()
  repo_index=$((repo_index+1))
  repo_dir=$(dirname "$repository")

  __enter_repo_dir "$repo_dir"

  __expand_args args parsed_args
  args_string="${parsed_args[*]}"
  [[ ${#args_string} -gt 60 ]] && args_string="${args_string:0:57}..."

  echo -e  "${GITTER_C_SUCCESS}${GITTER_PRIMARY_SYMBOL}${GITTER_C___RESET} ${GITTER_C_____DIM}[${repo_index}]${GITTER_C___RESET} $(__repo_status ".")"

  parsed_args=("${additional_args[@]}" "${parsed_args[@]}")
  if [[ "$GITTER_DRY_RUN" == true ]]; then
    echo -e "   ${GITTER_C_COMMAND}${command}${GITTER_C___RESET} ${GITTER_C_____ARG}${parsed_args[*]}${GITTER_C___RESET}"
  else
    echo -ne "   ${GITTER_C_____DIM}\$(${GITTER_C___RESET}${GITTER_C_COMMAND}${command}"
    echo -e  " ${GITTER_C_____ARG}${args_string}${GITTER_C___RESET}${GITTER_C_____DIM})${GITTER_C___RESET}"

    if [[ "$GITTER_ASK_CONFIRMATION"  == true  && "$exit_code" -eq 0 ]]; then
      __ask_to_proceed "$repo_index" "$total_repos"
      ask_to_proceed_rc=$?
      case $ask_to_proceed_rc in
        0 ) ;;
        1 ) __exit_repo_dir; continue ;;
        2 ) exit 1 ;;
      esac
    fi

    command -- "$command" "${parsed_args[@]}" 1> >(__handle_stdout) 2> >(__handle_stderr)
    exit_code=$?

    if [[ "$GITTER_CONTINUE_ON_ERROR" == false && "$exit_code" -ne 0 ]]; then
      __ask_on_error   "$exit_code" "$repo_index" "$total_repos"
    fi
  fi

  __exit_repo_dir
done

exit 0